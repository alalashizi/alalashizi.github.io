<!--
author: 奶昔-王乃茜
date: 2017-03-29 
title: ES6学习笔记（二）
tags: ES6
category: 前端
status: publish 
summary: 本文主要介绍ES6中的变量解构赋值。
-->
## 文章主要内容
    1.数组的解构赋值
    2.对象的解构赋值
    3.用途
    4.其他

## 1. 数组的解构赋值
## 基本用法
ES6允许按照一定的模式，从数组和对象中提取值，对变量进行赋值，这被称为解构

ES6以前，为变量赋值，只能写成这样
```
let a = 1;
let b = 2;
let c = 3;
```
要是需要声明很多的话，这样写不仅麻烦还累赘，现在你可以写成下面这样的形式，只用一行就可以代替
```
let [a, b, c] = [1, 2, 3];
```
上面代码表示，会从数组中依次提取值，按照对应的位置，对变量进行赋值。在解构过程中，会存在下面几种情况：

第一种，完全成功解构，等号右面的值和左面的变量依次匹配，就像上面的例子

第二种，不完全解构但是也算成功解构，这种情况是因为等号右面的值匹配完左面的变量后有剩余，像下面的两个例子
```
let [x,y] = [1, 2, 3];
x  // 1
y  // 2

let [a,[b],c] = [1, [2, 3], 4];
a  // 1
b  // 2
c  // 4
```
第三种，解构不成功，是因为左面变量的数量比右面提供的值多，就会解构不成功，多余的变量的值就等于undefined
```
let [bar, foo]=[1];
bar  // 1
foo  // undefined
```
第四种，会报错，因为等号右面的值不是可遍历的结构（要么转换为对象后不具备Iterator接口，要么本身就不具备Iterator接口）。事实上，只要某种数据结构具有Iterator接口，都可采用数组形式的解构赋值。
```
//  以下的指令运行都会报错
let [foo] = 1;
let [foo] = null;
let [foo] = undefined;
let [foo] = false;
let [foo] = NaN;
let [foo] = {};
```
p.s 与Iterator接口相关的知识点可参考其他的文章
## 默认值
解构赋值允许制定默认值，这点也是比较方便的
```
let [foo = true] = [];
foo // true

let [x, y = 'b'] = ['a'];  // x='a',y='b'
let [x, y = 'b'] = ['a',undefined];  // x='a',y='b'
```
默认值是当这个位置上的值严格等于undefined时（ES6是使用====进行严格比较），才会启用已经设定好的默认值，不然这个位置上的值还是那个赋给它的值

如果默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到它的时候才会进行求值
```
function f(){
    console.log(`lala`);
}

let [x = f()] = [1];
x // 1
```
## 2. 对象的解构赋值
解构不仅可以用于数组，也可适用于对象

对象的解构赋值与数组有一个很重要的不同。在数组中，变量的取值由它的位置决定；可是在对象中，变量必须与属性同名，才能取到正确的值，如果变量没有对应的同名属性，会导致取不到值，最后等于undefined，书写上要注意
```
let { bar, foo} = { foo:"aaa", bar:"bbb" };
foo  // "aaa"
bar  // "bbb"

let {baz} = { foo:"aaa", bar:"bbb" };
baz  // undefined
```
如果变量名与属性名不一致，必须写成下面这样
```
var { foo:baz } = { foo:'aaa', bar:'bbb' };
baz  // "aaa"

let obj = { first: 'hello', last: 'world' };
let { first: f, last: l } = obj;
f  // 'hello'
l  // 'world'
```
也就是说，变量的解构赋值实际上是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者，前者只是一种匹配模式，找到相同的，例如上面的例子，找到first，就会对应上，然后把hello赋给变量f

当采用这种写法时，变量的声明和赋值是一体的，这就意味着解构赋值的变量都会重新声明，当你使用let和const语句声明变量时要注意了，因为let和const不允许重复声明变量，会报错
```
let foo;
let {foo} = {foo: 1}; // SyntaxError: Duplicate declaration "foo"

let baz;
let {bar: baz} = {bar: 1}; // SyntaxError: Duplicate declaration "baz"

let foo;
({foo} = {foo: 1}); // 成功

let baz;
({bar: baz} = {bar: 1}); // 成功
```
对象的解构也是可以指定默认值，默认值生效的条件是，对象的属性值严格等于undefined，关于对象的解构赋值还有一些小的需要注意的点，详细可参考阮一峰的ES6入门
## 用途
变量的解构赋值有很多种用途。
1. 交换变量的值
   ```
    let x = 1;
    let y = 2;

    [x, y] = [y, x];
   ```
   上面的代码用来交换x和y的值，这样写很简洁，不用像原来的那样那么麻烦

2. 从函数返回多个值

   主要是取值的时候特别方便，因为函数只能返回一个值，要返回多个值就需要把它们放在数组或对象里

3. 函数参数的定义

   对于数组，顺序已经固定，逐个赋值就可以；对于对象就比较灵活，可以不依赖于位置，也不需要占位

4. 提取JSON数据

   对于提取JSON中的数据，也很有用，很方便就可以取到数据

5. 函数参数的默认值

   制定参数的默认值，使用变量解构赋值特别方便，就避免了原先那种累赘的写法（例如这样 var foo = config.foo || 'default foo';）
   
## 其他
字符串也可以解构赋值，在这个时候，字符串就被转换成了一个类似数组的对象，也拥有length属性

在解构赋值时，如果等号右面是数值和布尔值，则会先转为对象

解构赋值的规则是，只要等号右面的值不是对象或数组，就要先把它们转换为对象。由于undefined和null无法转换为对象，所以对它们进行解构赋值，就会报错

函数的参数也可以使用解构赋值，函数参数的解构也可以使用默认值
