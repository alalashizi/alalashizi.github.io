<!--
author: 奶昔-王乃茜
date: 2017-03-24 
title: ES6学习笔记（一）
tags: ES6
category: 前端
status: publish 
summary: 本文主要介绍ES6中的let和const命令以及块级作用域。
-->
## 文章主要内容	
   	1.let和const命令
    2.块级作用域

---
## 1. let和const命令

let和const命令是ES6新增用来声明变量的两条指令，在此之前ES5声明变量只有var命令和function命令，关于var这里有两点需要说明：	  
1. 使用var声明一个变量时变量声明无论出现在代码的任何位置，都会在任何代码执行之前处理，所以在代码中的任意位置声明变量总是等效于在代码开头声明，这意味着变量可以在声明之前使用（这就是变量声明提升，好多人觉得这样不好我倒是不觉得有什么，可能是会造成混乱，所以在let和const中改进了这一方面，let和const不会进行变量提升）。<br/>
2. 使用var声明的变量的作用域只有两种，一个是函数内部（声明在函数内）或者全局（声明在函数外），这样有时也会造成一些问题，比如使用for循环定义的变量会造成全局污染，需要使用闭包来保存一些变量，这个问题在let和const上都有了改进（let和const引入了块级作用域）。<br/>

p.s 关于function命令可以声明变量这个问题上，开始有点小纠结，不过下面的这段代码可以比较好的解释，其实那个函数名就是变量名


![](http://172.16.1.15:8888/files/1490090241367截图未命名.jpg)

## 1.1 let 命令
## 基本用法
let命令是用来声明变量，用法与var类似，但是所声明的变量，只在let命令所在的代码内有效。
```
{
     let a=10;
     var b=20;
}

a   //  ReferenceError: a is not defined.
b  //   20
```
上面的例子可以很好地说明let与var的不同，let声明的变量只在它所在的代码块中有效，在文章开头提到的使用var声明变量可能会造成全局污染,使用let可以很好的解决这个问题。例如下面的例子
```
for(var i = 0; i < 10;i++){}

console.log(i);
```
这时候是可以打印出i的值的，i的值为10，可是这个i只是我们暂时使用，用来计数的出了这个for循环就没有什么用了，我们并不希望它作为全局变量一直存在着，这个时候let就可以派上用场了，可以很好地帮我们解决这个问题
```
for(let i = 0;i < 10;i++){}

console.log(i);
```
这时候打印i的值会报错会提示 i is not defined，这样 i 就不会泄露成全局变量（过多的全局变量可能会造成全局污染） 

使用let还有一个很重要的好处，它可以解决一个很经典的问题（我第一次碰到这个问题的时候，觉得明明是显而易见，就应该能输出自己想要的结果，可是。。。它就是没输出）
```
for(var i = 0;i < 10; i++){

    setTimeout(function(){console.log('delay:'+i);},0)

}                          
```
这个时候输出的是 delay:10，打印了10遍，并没有像我们想象的那样会从0到9依次输出，这是因为setTimeout属于异步函数，它发现需要使用i这个变量，寻找i这个变量时i已经变成了10，要想达到我们的效果，可以使用立即执行函数
```
for(var i = 0;i < 10;i++){

    (function(index){

        setTimeout(function(){console.log('delay:'+index);},0)

    })(i);

}
```
像是这样使用立即执行函数是可以从delay : 0 打印到delay : 9，有了let就可以不用这么麻烦了，你可以像下面这样使用let，就可以从delay : 0 打印到delay : 9
```
for(let i = 0;i < 10;i++){

    setTimeout(function(){console.log('delay:'+i);},0)

}
```
## 不存在变量提升
由于var声明变量会存在变量提升这个问题（文章开头有提到），针对这个问题let特意做出了改进let不存在变量提升这个问题

## 暂时性死区
ES6中规定如果区块中存在let和const命令（就是在这个区块中使用了let或const命令，区块指一个花括号内的代码），这个区块就形成了封闭作用域，这里面的变量一定要先声明才能使用，如果不声明就使用就会报错，例如下面的例子
```
if(true){       //  代码块开始了（代码块就是区块）

     tmp = 'abc';  // ReferenceError 因为在这个代码块里有使用let，可是它还没声明你就开始用，报错
     console.log(tmp); // ReferenceError  报错原因同上

     let tmp;  // 声明了，下面用就不会报错了
     console.log(tmp);  // undefined 只声明没有赋值，所以输出的是undefined

     tmp = 123; 
     console.log(tmp); // 123 既声明又赋值了，输出结果

}
```
还有一些死区比较隐蔽，可能会报错，需要擦亮双眼好好看看，例如下面的例子。
```
function bar(x = y,y = 2){
      return [x,y];
}
bar(); // 报错
```
上面调用bar会报错是因为参数x默认值等于另一个参数y,而此时y还没有被声明。

## 不允许重复声明
let不允许在相同作用域内，重复声明同一个变量，会报错
```
function func(arg){
     let arg;  // 报错
}
```
你可以像下面这样写，就不会报错了，再增加一个作用域
```
function func(arg){
    {
        let arg; // 这样就不报错了
    }
}
```
## 1.2 const命令
## 基本用法
const命令声明一个只读的变量。一旦声明，常量的值就不能改变,改变常量的值会报错。const一旦声明变量，就必须立即初始化，对于const来说，只声明不赋值，就会报错。
```
const PI;  //只这样写就会报错，SyntaxError: Missing initializer in const declaration  因为只声明了却没有赋值

const PT = 3.1415;  //这样写就不会报错了
PI  // 3.1415

PI = 3;  // 这样会报错 TypeError: Assignment to constant variable.
```
const与let有很多的相同点，都是只在声明所在的块级作用域中有效，变量都不提升，都存在暂时性死区（只能在声明的位置后面使用），都是不可重复声明，使用不当就会报错。
## 本质
const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址不得改动。对于简单类型的数据（数值，字符串，布尔值），值就保存在变量指向的那个内存地址，当你使用const给一个变量赋值了，再给它赋值就会报错，就写不进去了。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的是个指针，const只能保证这个指针是固定的，它指向的数据类型却是可变的，不过可以对对象和数组进行操作，例子如下所示。
```
const foo = {};  // 这是个对象的例子

foo.prop = 123;  // 为foo添加一个属性，可以成功，可以对对象进行操作
foo.prop // 123

foo = {};  // TypeError: "foo" is read-only 给foo赋值，它指向了另一个对象，就会报错
```
```
const a = [];     // 这是个数组的例子
a.push('hello');  // 可以执行
a.length = 0;     // 可以执行

a = ['Dave'];     // 会报错，因为是给它赋值
```
## 2. 块级作用域
ES5中并没有块级作用域这个概念，这会带来很多的问题，例如：内层变量可能会覆盖外层变量，也会把一些变量泄露成全局变量。let实际上为JavaScript新增了块级作用域，使得外层作用域无法读取内层作用域的变量，内层作用域也可以定义外层作用域的同名变量。例子如下所示：
```
function f1(){
    let n = 5;
    if(true){
        let n = 10;
    }
    console.log(n);  // 5
}
```
## 块级作用域与函数声明
在ES5中是不允许函数在块级作用域中声明，可是浏览器却支持在块级作用域中声明函数，这块就会有点小出入。后来ES6引入了块级作用域，明确允许在块级作用域中声明函数。ES6规定，块级作用域中，函数声明语句的行为类似于let，在块级作用域之外不可引用。可是这样又会出现问题，可能会存在代码不兼容的问题，为了兼容以前的代码，ES6规定浏览器的实现可以不遵守上面的规定，有自己的行为方式。考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数，如果确实需要，也应该写成函数表达式，而不是函数声明语句。
```
//函数声明语句的写法如下
{
    let a = 'secret';
    function f(){
        return a;
    }
}

//函数表达式的写法如下
{
    let a = 'secret';
    let f = function(){
        return a;
    };
}
```
此外，ES6的块级作用域允许声明函数的规则，只能在大括号中使用，如果没有大括号，就会报错。









   

